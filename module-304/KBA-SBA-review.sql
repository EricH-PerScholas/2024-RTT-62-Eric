select p.id
from products p, orderdetails od
where p.id = od.product_id;

select * from employees;

select employee_id, salary
from employees INNER JOIN salaries on employee_id = employee_id
where salary >= 75000;

select * from employees;

select * from employees where firstname like 'A%'
union -- this is equaivlant of distinct
select *  from employees where firstname like 'G%'
union all
select * from employees where lastname like 'B%';


-- I want to see the list of products that have never been sold
select product_id from orderdetails;
select * from products p where p.id not in (select product_id from orderdetails);

select *, (select count(*) from orderdetails od where od.product_id = p.id) as product_count
from products p
order by product_count desc;

-- I refrain from doing this when I can
select * from 
	( select * from products p where p.product_name like '19%' ) a
where a.productline_id = 2;

-- 
-- for this we can use the format function 
select p.product_name, format(max(quantity_ordered),2) as "max_offer", format(min(quantity_ordered),2) as min_buy_price, 
format(round(avg(quantity_ordered),2),2) as avg_buy_price, count(*) as product_count
from products p, orderdetails od
where p.id = od.product_id
group by od.product_id;

-- transaction important parts
-- 1) A transaction can include one or more insert, update, or delete statements
-- 2) Any changes made inside a transaction are not visible to other database users until you perform a commit
-- 3) commit is used to save the transaction
-- 4) rollback discards the changes in the transaction

-- understand what is an ambigous colum in the database

-- we did update statements and you need to know the format for the update statement
-- UPDATE <tablename> SET <columnname> = <value> WHERE ...;
select * from offices;
update offices set address_line2 = 'unknown' where id = 8;

-- we know our basic aggergate functions - min, max, avg, count, sum

-- why is normalization important
-- 1) reduce data reduncancy
-- 2) imporve data integretiy 
-- 3) we want to simplify data maintnance
-- 4) ( we have proper FK relationships and proper naming of tables and columns )
-- 5) ( we store data with a like measurement as in .. we use feet, or inches but not both in the same column )

-- anatomy of a select statemnt
SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
LIMIT

-- primary key
-- 1) primary is always unique and can be used to identify a single unique record in a table 
-- 2) by definition a primary key is unique and does not need addtional configruion
-- 3) PRIMARY KEY CAN NOT CONTAIN NULL VALUES!!!!!!!!! *****
	select * from products where id is null; -- this will return 0 rows because the PK can not be null
-- 4) The value of a primary key is automatically generated by using AUTO_INCREMENT (AI)
-- 5) A PK can consist of multiple columns - this is a true statement even tho you would never do it on the job
-- 6) Is used to access database records faster -- PK is the fastest way to lookup a record in the database
-- 7) Help maintian referenetial integrity
-- 8) PK should be - numeric, not null, auto incremented, and unique **

-- IS NULL vs = NULL
select * from offices where address_line2 = null;  -- this will always return 0 records because its not correct syntax
select * from offices where address_line2 IS NULL; -- this will work properly
select * from offices where address_line2 IS NOT NULL; -- this will work propertly

-- thought processes
-- 1) identify the sub query and try to first think about what that subquery will return
-- 2) then pay attention to the where clause for anything that negates the answer
-- 3) Then can consider the select or update part of the query

-- what does the where clause do?  ***
-- defines one or more conditions that must be met for data to be returned

-- why do we use constraints on the database?
-- 1) Limit the data that goes into the table for business requirements
-- 2) Enhances data integrity

-- what do we know about joins
-- 1) There is no known use for a cross join
-- 2) We know that a self join is when you are connecting to the id colum in the same table
-- 3) We know that Non-Equi-Join is not even a real join
-- 4) We know that Inner Join can connect two or more tables

-- 5) This is a true statement - Multiple types of joins can be used in the same query

-- what is the default order by - asending

-- when adding a FK relationship which table to we add the FK relationship to?
-- lets consider products and orderdetails .. which table ahs the FK ?
-- its the table with the many side of the relationship 
-- it is not the table with the id side
-- the ALTER TABLE command with the ADD clause is needed to manually create a FK

-- a FK is not required for a database - they are good practice but you can create a databaes without using a FK
